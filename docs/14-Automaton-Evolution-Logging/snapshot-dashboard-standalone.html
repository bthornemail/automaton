<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automaton Snapshot Analysis Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }
        h1 { color: #667eea; font-size: 2.5em; margin-bottom: 10px; }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }
        .controls input[type="file"] { margin: 10px 0; }
        .controls button {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
        }
        .controls button:hover { background: #764ba2; }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }
        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
        }
        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            height: 400px;
        }
        .chart-title {
            font-size: 1.5em;
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
        }
        .progress-table {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            overflow-x: auto;
        }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #eee; }
        th { background: #667eea; color: white; font-weight: bold; }
        tr:hover { background: #f5f5f5; }
        .status-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
            color: white;
        }
        .status-low { background: #4caf50; }
        .status-medium { background: #ff9800; }
        .status-high { background: #f44336; }
        .status-stable { background: #4caf50; }
        .status-good { background: #2196f3; }
        .loading { text-align: center; padding: 50px; color: white; font-size: 1.2em; }
        .error {
            background: #f44336;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Automaton Snapshot Analysis Dashboard</h1>
            <p>Upload snapshot JSON files to analyze automaton evolution</p>
        </header>

        <div class="controls">
            <div class="info-box">
                <strong>üìÅ How to use:</strong><br>
                1. Select multiple snapshot JSON files from the <code>snapshots-memory/</code> directory<br>
                2. Click "Analyze Snapshots" to process them<br>
                3. View charts, statistics, and progression tables below
            </div>
            <input type="file" id="fileInput" multiple accept="application/json">
            <button onclick="loadFiles()">üìä Analyze Snapshots</button>
            <button onclick="loadSample()">üìã Load Sample Data</button>
            <button onclick="exportReport()">üíæ Export Report</button>
        </div>

        <div id="loading" class="loading" style="display: none;">‚è≥ Processing snapshots...</div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="dashboard" style="display: none;">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Snapshots</div>
                    <div class="stat-value" id="totalSnapshots">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Time Span</div>
                    <div class="stat-value" id="timeSpan">0s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Start Memory</div>
                    <div class="stat-value" id="startMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">End Memory</div>
                    <div class="stat-value" id="endMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Memory</div>
                    <div class="stat-value" id="peakMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Change</div>
                    <div class="stat-value" id="memoryChange">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Stability</div>
                    <div class="stat-value" id="memoryStability">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Quality Score</div>
                    <div class="stat-value" id="qualityScore">-</div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Memory Usage Over Time</div>
                <canvas id="memoryChart"></canvas>
            </div>

            <div class="chart-container">
                <div class="chart-title">Memory Pressure Distribution</div>
                <canvas id="pressureChart"></canvas>
            </div>

            <div class="chart-container">
                <div class="chart-title">Dimension Distribution</div>
                <canvas id="dimensionChart"></canvas>
            </div>

            <div class="progress-table">
                <h2 class="chart-title">Snapshot Progression</h2>
                <table id="progressionTable">
                    <thead>
                        <tr>
                            <th>Stage</th>
                            <th>Memory (MB)</th>
                            <th>Objects</th>
                            <th>Modifications</th>
                            <th>Dimension</th>
                            <th>Pressure</th>
                        </tr>
                    </thead>
                    <tbody id="progressionBody"></tbody>
                </table>
            </div>

            <div class="progress-table">
                <h2 class="chart-title">Memory Growth Phases</h2>
                <table id="phasesTable">
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Range</th>
                            <th>Start Memory</th>
                            <th>End Memory</th>
                            <th>Growth</th>
                            <th>Growth Rate</th>
                            <th>Objects Change</th>
                        </tr>
                    </thead>
                    <tbody id="phasesBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let snapshots = [];
        let memoryChart, pressureChart, dimensionChart;

        function loadFiles() {
            const fileInput = document.getElementById('fileInput');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) {
                showError('Please select snapshot files first.');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('dashboard').style.display = 'none';

            snapshots = [];
            let loaded = 0;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        snapshots.push(data);
                        loaded++;
                        
                        if (loaded === files.length) {
                            snapshots.sort((a, b) => a.timestamp - b.timestamp);
                            document.getElementById('loading').style.display = 'none';
                            analyzeSnapshots();
                        }
                    } catch (err) {
                        console.error('Failed to parse', file.name, err);
                        loaded++;
                        if (loaded === files.length && snapshots.length > 0) {
                            snapshots.sort((a, b) => a.timestamp - b.timestamp);
                            document.getElementById('loading').style.display = 'none';
                            analyzeSnapshots();
                        }
                    }
                };
                reader.readAsText(file);
            });
        }

        function loadSample() {
            // Load embedded sample data
            const sampleData = [
                {
                    "timestamp": 1762632118181,
                    "isoTime": "2025-11-08T20:01:58.181Z",
                    "memory": { "heapUsed": 8325024, "heapTotal": 11145216, "rss": 119828480 },
                    "automatonState": { "objectCount": 552, "selfModificationCount": 407, "currentDimension": 0 },
                    "reasoning": { "newObjects": 552, "newModifications": 407, "memoryDelta": 0, "memoryPressure": "low" }
                },
                {
                    "timestamp": 1762632119432,
                    "isoTime": "2025-11-08T20:01:59.432Z",
                    "memory": { "heapUsed": 31768320, "heapTotal": 11145216, "rss": 119828480 },
                    "automatonState": { "objectCount": 613, "selfModificationCount": 524, "currentDimension": 0 },
                    "reasoning": { "newObjects": 7, "newModifications": 7, "memoryDelta": 23445760, "memoryPressure": "medium" }
                },
                {
                    "timestamp": 1762632120683,
                    "isoTime": "2025-11-08T20:02:00.683Z",
                    "memory": { "heapUsed": 28391344, "heapTotal": 139300864, "rss": 268509184 },
                    "automatonState": { "objectCount": 422, "selfModificationCount": 273, "currentDimension": 0 },
                    "reasoning": { "newObjects": 0, "newModifications": 0, "memoryDelta": -3376976, "memoryPressure": "low" }
                }
            ];
            
            snapshots = sampleData;
            analyzeSnapshots();
        }

        function analyzeSnapshots() {
            if (snapshots.length === 0) {
                showError('No snapshots loaded.');
                return;
            }

            document.getElementById('dashboard').style.display = 'block';
            const stats = calculateStats();
            displayStats(stats);
            createCharts(stats);
            displayProgression(stats);
            displayPhases(stats);
        }

        function calculateStats() {
            const first = snapshots[0];
            const last = snapshots[snapshots.length - 1];
            const totalTime = (last.timestamp - first.timestamp) / 1000;

            const memValues = snapshots.map(s => s.memory.heapUsed / 1024 / 1024);
            const memStart = memValues[0];
            const memEnd = memValues[memValues.length - 1];
            const memPeak = Math.max(...memValues);
            const memMin = Math.min(...memValues);
            const memChange = memEnd - memStart;

            const memDeltas = [];
            for (let i = 1; i < memValues.length; i++) {
                memDeltas.push(memValues[i] - memValues[i - 1]);
            }
            const avgDelta = memDeltas.reduce((a, b) => a + b, 0) / memDeltas.length;
            const variance = memDeltas.reduce((sum, d) => sum + Math.pow(d - avgDelta, 2), 0) / memDeltas.length;
            const volatility = Math.sqrt(variance);

            const pressureCounts = {};
            snapshots.forEach(s => {
                const pressure = s.reasoning?.memoryPressure || 'unknown';
                pressureCounts[pressure] = (pressureCounts[pressure] || 0) + 1;
            });

            const dimCounts = {};
            snapshots.forEach(s => {
                const dim = s.automatonState?.currentDimension || 0;
                dimCounts[dim] = (dimCounts[dim] || 0) + 1;
            });

            const activeSnapshots = snapshots.filter((s, i) => 
                i > 0 && ((s.reasoning?.newObjects || 0) > 0 || (s.reasoning?.newModifications || 0) > 0)
            ).length;

            const memoryEfficient = snapshots.filter(s => {
                const pressure = s.reasoning?.memoryPressure || 'unknown';
                return pressure === 'low' || pressure === 'medium';
            }).length;
            
            const qualityScore = snapshots.length > 1 ? (
                (activeSnapshots / (snapshots.length - 1)) * 0.4 +
                (memoryEfficient / snapshots.length) * 0.3 +
                (volatility < 50 ? 1 : 0) * 0.3
            ) * 100 : 0;

            const progressionPoints = [
                { label: 'Start (0%)', index: 0 },
                { label: 'Early (10%)', index: Math.floor(snapshots.length * 0.1) },
                { label: 'Mid (25%)', index: Math.floor(snapshots.length * 0.25) },
                { label: 'Mid (50%)', index: Math.floor(snapshots.length * 0.5) },
                { label: 'Mid (75%)', index: Math.floor(snapshots.length * 0.75) },
                { label: 'Late (90%)', index: Math.floor(snapshots.length * 0.9) },
                { label: 'End (100%)', index: snapshots.length - 1 },
            ].map(p => ({
                ...p,
                snapshot: snapshots[p.index] || snapshots[snapshots.length - 1]
            }));

            const phases = [];
            const phaseSize = Math.max(1, Math.floor(snapshots.length / 4));
            for (let i = 0; i < 4 && i * phaseSize < snapshots.length; i++) {
                const startIdx = i * phaseSize;
                const endIdx = Math.min((i + 1) * phaseSize, snapshots.length - 1);
                if (startIdx >= endIdx) break;
                
                const startMem = snapshots[startIdx].memory.heapUsed / 1024 / 1024;
                const endMem = snapshots[endIdx].memory.heapUsed / 1024 / 1024;
                const growth = endMem - startMem;
                const timeDelta = (snapshots[endIdx].timestamp - snapshots[startIdx].timestamp) / 1000;
                const growthRate = timeDelta > 0 ? growth / timeDelta : 0;
                const objStart = snapshots[startIdx].automatonState?.objectCount || 0;
                const objEnd = snapshots[endIdx].automatonState?.objectCount || 0;
                
                phases.push({
                    phase: i + 1,
                    range: `${startIdx} ‚Üí ${endIdx}`,
                    startMem: startMem.toFixed(2),
                    endMem: endMem.toFixed(2),
                    growth: growth > 0 ? `+${growth.toFixed(2)}` : growth.toFixed(2),
                    growthRate: growthRate.toFixed(4),
                    objectsChange: objEnd - objStart
                });
            }

            return {
                totalSnapshots: snapshots.length,
                timeSpan: totalTime,
                memStart, memEnd, memPeak, memMin, memChange,
                volatility, pressureCounts, dimCounts,
                activeSnapshots, qualityScore, progressionPoints, phases,
                memValues, timestamps: snapshots.map(s => new Date(s.timestamp))
            };
        }

        function displayStats(stats) {
            document.getElementById('totalSnapshots').textContent = stats.totalSnapshots.toLocaleString();
            document.getElementById('timeSpan').textContent = `${stats.timeSpan.toFixed(1)}s`;
            document.getElementById('startMemory').textContent = `${stats.memStart.toFixed(2)}MB`;
            document.getElementById('endMemory').textContent = `${stats.memEnd.toFixed(2)}MB`;
            document.getElementById('peakMemory').textContent = `${stats.memPeak.toFixed(2)}MB`;
            document.getElementById('memoryChange').textContent = `${stats.memChange > 0 ? '+' : ''}${stats.memChange.toFixed(2)}MB`;
            
            const stabilityClass = stats.volatility < 10 ? 'status-stable' : stats.volatility < 50 ? 'status-good' : 'status-high';
            document.getElementById('memoryStability').innerHTML = `<span class="status-badge ${stabilityClass}">${stats.volatility.toFixed(2)}MB</span>`;
            
            const qualityClass = stats.qualityScore >= 80 ? 'status-stable' : stats.qualityScore >= 60 ? 'status-good' : stats.qualityScore >= 40 ? 'status-medium' : 'status-high';
            document.getElementById('qualityScore').innerHTML = `<span class="status-badge ${qualityClass}">${stats.qualityScore.toFixed(1)}/100</span>`;
        }

        function createCharts(stats) {
            const sampleRate = Math.max(1, Math.floor(stats.memValues.length / 100));
            
            const memCtx = document.getElementById('memoryChart').getContext('2d');
            if (memoryChart) memoryChart.destroy();
            memoryChart = new Chart(memCtx, {
                type: 'line',
                data: {
                    labels: stats.timestamps.filter((_, i) => i % sampleRate === 0).map(t => t.toLocaleTimeString()),
                    datasets: [{
                        label: 'Memory Usage (MB)',
                        data: stats.memValues.filter((_, i) => i % sampleRate === 0),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: false } }
                }
            });

            const pressureCtx = document.getElementById('pressureChart').getContext('2d');
            if (pressureChart) pressureChart.destroy();
            pressureChart = new Chart(pressureCtx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(stats.pressureCounts),
                    datasets: [{
                        data: Object.values(stats.pressureCounts),
                        backgroundColor: ['#4caf50', '#ff9800', '#f44336', '#9e9e9e']
                    }]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });

            const dimCtx = document.getElementById('dimensionChart').getContext('2d');
            if (dimensionChart) dimensionChart.destroy();
            const dimLabels = Object.keys(stats.dimCounts).sort((a, b) => parseInt(a) - parseInt(b));
            dimensionChart = new Chart(dimCtx, {
                type: 'bar',
                data: {
                    labels: dimLabels.map(d => `${d}D`),
                    datasets: [{
                        label: 'Snapshots',
                        data: dimLabels.map(d => stats.dimCounts[d]),
                        backgroundColor: '#764ba2'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: { y: { beginAtZero: true } }
                }
            });
        }

        function displayProgression(stats) {
            const tbody = document.getElementById('progressionBody');
            tbody.innerHTML = '';
            stats.progressionPoints.forEach(p => {
                const s = p.snapshot;
                const memMB = s.memory.heapUsed / 1024 / 1024;
                const pressure = s.reasoning?.memoryPressure || 'unknown';
                const pressureClass = pressure === 'low' ? 'status-low' : pressure === 'medium' ? 'status-medium' : 'status-high';
                const row = tbody.insertRow();
                row.insertCell(0).textContent = p.label;
                row.insertCell(1).textContent = memMB.toFixed(2);
                row.insertCell(2).textContent = s.automatonState?.objectCount || 0;
                row.insertCell(3).textContent = s.automatonState?.selfModificationCount || 0;
                row.insertCell(4).textContent = `${s.automatonState?.currentDimension || 0}D`;
                row.insertCell(5).innerHTML = `<span class="status-badge ${pressureClass}">${pressure.toUpperCase()}</span>`;
            });
        }

        function displayPhases(stats) {
            const tbody = document.getElementById('phasesBody');
            tbody.innerHTML = '';
            stats.phases.forEach(p => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = `Phase ${p.phase}`;
                row.insertCell(1).textContent = p.range;
                row.insertCell(2).textContent = `${p.startMem}MB`;
                row.insertCell(3).textContent = `${p.endMem}MB`;
                row.insertCell(4).textContent = `${p.growth}MB`;
                row.insertCell(5).textContent = `${p.growthRate}MB/sec`;
                row.insertCell(6).textContent = p.objectsChange > 0 ? `+${p.objectsChange}` : p.objectsChange;
            });
        }

        function showError(message) {
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
        }

        function exportReport() {
            if (snapshots.length === 0) {
                alert('No snapshots loaded.');
                return;
            }
            const stats = calculateStats();
            const report = {
                generated: new Date().toISOString(),
                summary: {
                    totalSnapshots: stats.totalSnapshots,
                    timeSpan: stats.timeSpan,
                    memory: {
                        start: stats.memStart,
                        end: stats.memEnd,
                        peak: stats.memPeak,
                        change: stats.memChange,
                        volatility: stats.volatility
                    },
                    qualityScore: stats.qualityScore,
                    pressureDistribution: stats.pressureCounts,
                    dimensionDistribution: stats.dimCounts
                },
                progression: stats.progressionPoints.map(p => ({
                    stage: p.label,
                    memory: p.snapshot.memory.heapUsed / 1024 / 1024,
                    objects: p.snapshot.automatonState?.objectCount || 0,
                    modifications: p.snapshot.automatonState?.selfModificationCount || 0,
                    dimension: p.snapshot.automatonState?.currentDimension || 0,
                    pressure: p.snapshot.reasoning?.memoryPressure || 'unknown'
                })),
                phases: stats.phases
            };
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snapshot-analysis-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
