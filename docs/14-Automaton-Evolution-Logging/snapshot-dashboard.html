<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automaton Snapshot Analysis Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls input, .controls button {
            padding: 10px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 14px;
        }

        .controls input {
            flex: 1;
            min-width: 200px;
        }

        .controls button {
            background: #667eea;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .controls button:hover {
            background: #764ba2;
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-5px);
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            height: 400px;
        }

        .chart-title {
            font-size: 1.5em;
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-table {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .status-low { background: #4caf50; color: white; }
        .status-medium { background: #ff9800; color: white; }
        .status-high { background: #f44336; color: white; }
        .status-stable { background: #4caf50; color: white; }
        .status-good { background: #2196f3; color: white; }

        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 1.2em;
        }

        .error {
            background: #f44336;
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .dimension-bar {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }

        .dimension-label {
            width: 50px;
            font-weight: bold;
        }

        .dimension-bar-fill {
            height: 30px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 5px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Automaton Snapshot Analysis Dashboard</h1>
            <p class="subtitle">Real-time visualization of automaton evolution and memory patterns</p>
        </header>

        <div class="controls">
            <input type="text" id="snapshotPath" placeholder="Path to snapshots-memory directory (e.g., ../../snapshots-memory)" value="../../snapshots-memory">
            <input type="number" id="sampleSize" placeholder="Sample size (0 = all)" value="1000" min="0">
            <button onclick="loadSnapshots()">üìä Load Snapshots</button>
            <button onclick="analyzeSnapshots()">üîç Analyze</button>
            <button onclick="exportReport()">üíæ Export Report</button>
        </div>

        <div id="loading" class="loading" style="display: none;">
            ‚è≥ Loading snapshots...
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="dashboard" style="display: none;">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Snapshots</div>
                    <div class="stat-value" id="totalSnapshots">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Time Span</div>
                    <div class="stat-value" id="timeSpan">0s</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Start Memory</div>
                    <div class="stat-value" id="startMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">End Memory</div>
                    <div class="stat-value" id="endMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Peak Memory</div>
                    <div class="stat-value" id="peakMemory">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Change</div>
                    <div class="stat-value" id="memoryChange">0MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Stability</div>
                    <div class="stat-value" id="memoryStability">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Quality Score</div>
                    <div class="stat-value" id="qualityScore">-</div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">Memory Usage Over Time</div>
                <canvas id="memoryChart"></canvas>
            </div>

            <div class="chart-container">
                <div class="chart-title">Memory Pressure Distribution</div>
                <canvas id="pressureChart"></canvas>
            </div>

            <div class="chart-container">
                <div class="chart-title">Dimension Distribution</div>
                <canvas id="dimensionChart"></canvas>
            </div>

            <div class="progress-table">
                <h2 class="chart-title">Snapshot Progression</h2>
                <table id="progressionTable">
                    <thead>
                        <tr>
                            <th>Stage</th>
                            <th>Memory (MB)</th>
                            <th>Objects</th>
                            <th>Modifications</th>
                            <th>Dimension</th>
                            <th>Pressure</th>
                        </tr>
                    </thead>
                    <tbody id="progressionBody"></tbody>
                </table>
            </div>

            <div class="progress-table">
                <h2 class="chart-title">Memory Growth Phases</h2>
                <table id="phasesTable">
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Range</th>
                            <th>Start Memory</th>
                            <th>End Memory</th>
                            <th>Growth</th>
                            <th>Growth Rate</th>
                            <th>Objects Change</th>
                        </tr>
                    </thead>
                    <tbody id="phasesBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let snapshots = [];
        let memoryChart, pressureChart, dimensionChart;

        async function loadSnapshots() {
            const snapshotPath = document.getElementById('snapshotPath').value;
            const sampleSize = parseInt(document.getElementById('sampleSize').value) || 0;
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('dashboard').style.display = 'none';

            try {
                // For local file access, we'll use fetch with a local server or File API
                // This assumes snapshots are accessible via HTTP or we're using a local server
                const response = await fetch(`${snapshotPath}/.snapshot-list.json`);
                
                if (!response.ok) {
                    // Try to load sample snapshots directly
                    await loadSampleSnapshots(snapshotPath, sampleSize);
                    return;
                }

                const fileList = await response.json();
                const filesToLoad = sampleSize > 0 ? fileList.slice(0, sampleSize) : fileList;
                
                snapshots = [];
                for (const file of filesToLoad) {
                    try {
                        const fileResponse = await fetch(`${snapshotPath}/${file}`);
                        if (fileResponse.ok) {
                            const data = await fileResponse.json();
                            snapshots.push(data);
                        }
                    } catch (e) {
                        console.warn(`Failed to load ${file}:`, e);
                    }
                }

                snapshots.sort((a, b) => a.timestamp - b.timestamp);
                document.getElementById('loading').style.display = 'none';
                analyzeSnapshots();
            } catch (error) {
                // Fallback: try to load via File API or show instructions
                document.getElementById('loading').style.display = 'none';
                showError('Unable to load snapshots directly. Please use a local web server or load via file input.');
                showFileInput();
            }
        }

        async function loadSampleSnapshots(path, sampleSize) {
            // Try to load a few sample files to demonstrate
            const sampleFiles = [
                'memory-snapshot-000001-1762632118181.json',
                'memory-snapshot-010000-1762632119432.json',
                'memory-snapshot-020000-1762632120683.json',
            ];

            snapshots = [];
            for (const file of sampleFiles) {
                try {
                    const response = await fetch(`${path}/${file}`);
                    if (response.ok) {
                        const data = await response.json();
                        snapshots.push(data);
                    }
                } catch (e) {
                    console.warn(`Failed to load ${file}:`, e);
                }
            }

            if (snapshots.length > 0) {
                document.getElementById('loading').style.display = 'none';
                analyzeSnapshots();
            } else {
                showError('No snapshots found. Please ensure the path is correct and snapshots exist.');
            }
        }

        function showFileInput() {
            const controls = document.querySelector('.controls');
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.multiple = true;
            fileInput.accept = 'application/json';
            fileInput.onchange = handleFileSelect;
            controls.appendChild(fileInput);
        }

        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            snapshots = [];
            
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        snapshots.push(data);
                        if (snapshots.length === files.length) {
                            snapshots.sort((a, b) => a.timestamp - b.timestamp);
                            analyzeSnapshots();
                        }
                    } catch (err) {
                        console.error('Failed to parse', file.name, err);
                    }
                };
                reader.readAsText(file);
            });
        }

        function analyzeSnapshots() {
            if (snapshots.length === 0) {
                showError('No snapshots loaded. Please load snapshots first.');
                return;
            }

            document.getElementById('dashboard').style.display = 'block';
            
            // Calculate statistics
            const stats = calculateStats();
            displayStats(stats);
            createCharts(stats);
            displayProgression(stats);
            displayPhases(stats);
        }

        function calculateStats() {
            const first = snapshots[0];
            const last = snapshots[snapshots.length - 1];
            const totalTime = (last.timestamp - first.timestamp) / 1000;

            // Memory stats
            const memValues = snapshots.map(s => s.memory.heapUsed / 1024 / 1024);
            const memStart = memValues[0];
            const memEnd = memValues[memValues.length - 1];
            const memPeak = Math.max(...memValues);
            const memMin = Math.min(...memValues);
            const memChange = memEnd - memStart;
            const memRange = memPeak - memMin;

            // Memory volatility
            const memDeltas = [];
            for (let i = 1; i < memValues.length; i++) {
                memDeltas.push(memValues[i] - memValues[i - 1]);
            }
            const avgDelta = memDeltas.reduce((a, b) => a + b, 0) / memDeltas.length;
            const variance = memDeltas.reduce((sum, d) => sum + Math.pow(d - avgDelta, 2), 0) / memDeltas.length;
            const volatility = Math.sqrt(variance);

            // Pressure distribution
            const pressureCounts = {};
            snapshots.forEach(s => {
                const pressure = s.reasoning.memoryPressure || 'unknown';
                pressureCounts[pressure] = (pressureCounts[pressure] || 0) + 1;
            });

            // Dimension distribution
            const dimCounts = {};
            snapshots.forEach(s => {
                const dim = s.automatonState.currentDimension || 0;
                dimCounts[dim] = (dimCounts[dim] || 0) + 1;
            });

            // Active snapshots
            const activeSnapshots = snapshots.filter((s, i) => 
                i > 0 && (s.reasoning.newObjects > 0 || s.reasoning.newModifications > 0)
            ).length;

            // Quality score
            const memoryEfficient = snapshots.filter(s => 
                s.reasoning.memoryPressure === 'low' || s.reasoning.memoryPressure === 'medium'
            ).length;
            
            const qualityScore = (
                (activeSnapshots / (snapshots.length - 1)) * 0.4 +
                (memoryEfficient / snapshots.length) * 0.3 +
                (volatility < 50 ? 1 : 0) * 0.3
            ) * 100;

            // Sample progression points
            const progressionPoints = [
                { label: 'Start (0%)', index: 0 },
                { label: 'Early (10%)', index: Math.floor(snapshots.length * 0.1) },
                { label: 'Mid (25%)', index: Math.floor(snapshots.length * 0.25) },
                { label: 'Mid (50%)', index: Math.floor(snapshots.length * 0.5) },
                { label: 'Mid (75%)', index: Math.floor(snapshots.length * 0.75) },
                { label: 'Late (90%)', index: Math.floor(snapshots.length * 0.9) },
                { label: 'End (100%)', index: snapshots.length - 1 },
            ].map(p => ({
                ...p,
                snapshot: snapshots[p.index]
            }));

            // Growth phases
            const phases = [];
            const phaseSize = Math.floor(snapshots.length / 4);
            for (let i = 0; i < 4; i++) {
                const startIdx = i * phaseSize;
                const endIdx = Math.min((i + 1) * phaseSize, snapshots.length - 1);
                const startMem = snapshots[startIdx].memory.heapUsed / 1024 / 1024;
                const endMem = snapshots[endIdx].memory.heapUsed / 1024 / 1024;
                const growth = endMem - startMem;
                const timeDelta = (snapshots[endIdx].timestamp - snapshots[startIdx].timestamp) / 1000;
                const growthRate = growth / timeDelta;
                const objStart = snapshots[startIdx].automatonState.objectCount;
                const objEnd = snapshots[endIdx].automatonState.objectCount;
                
                phases.push({
                    phase: i + 1,
                    range: `${startIdx} ‚Üí ${endIdx}`,
                    startMem: startMem.toFixed(2),
                    endMem: endMem.toFixed(2),
                    growth: growth > 0 ? `+${growth.toFixed(2)}` : growth.toFixed(2),
                    growthRate: growthRate.toFixed(4),
                    objectsChange: objEnd - objStart
                });
            }

            return {
                totalSnapshots: snapshots.length,
                timeSpan: totalTime,
                memStart,
                memEnd,
                memPeak,
                memMin,
                memChange,
                memRange,
                volatility,
                pressureCounts,
                dimCounts,
                activeSnapshots,
                qualityScore,
                progressionPoints,
                phases,
                memValues,
                timestamps: snapshots.map(s => new Date(s.timestamp))
            };
        }

        function displayStats(stats) {
            document.getElementById('totalSnapshots').textContent = stats.totalSnapshots.toLocaleString();
            document.getElementById('timeSpan').textContent = `${stats.timeSpan.toFixed(1)}s (${(stats.timeSpan/60).toFixed(1)}min)`;
            document.getElementById('startMemory').textContent = `${stats.memStart.toFixed(2)}MB`;
            document.getElementById('endMemory').textContent = `${stats.memEnd.toFixed(2)}MB`;
            document.getElementById('peakMemory').textContent = `${stats.memPeak.toFixed(2)}MB`;
            document.getElementById('memoryChange').textContent = `${stats.memChange > 0 ? '+' : ''}${stats.memChange.toFixed(2)}MB`;
            
            const stabilityClass = stats.volatility < 10 ? 'status-stable' : stats.volatility < 50 ? 'status-good' : 'status-high';
            document.getElementById('memoryStability').innerHTML = `<span class="status-badge ${stabilityClass}">${stats.volatility.toFixed(2)}MB</span>`;
            
            const qualityClass = stats.qualityScore >= 80 ? 'status-stable' : stats.qualityScore >= 60 ? 'status-good' : stats.qualityScore >= 40 ? 'status-medium' : 'status-high';
            document.getElementById('qualityScore').innerHTML = `<span class="status-badge ${qualityClass}">${stats.qualityScore.toFixed(1)}/100</span>`;
        }

        function createCharts(stats) {
            // Memory chart
            const memCtx = document.getElementById('memoryChart').getContext('2d');
            if (memoryChart) memoryChart.destroy();
            memoryChart = new Chart(memCtx, {
                type: 'line',
                data: {
                    labels: stats.timestamps.map((t, i) => i % Math.ceil(stats.timestamps.length / 50) === 0 ? t.toLocaleTimeString() : ''),
                    datasets: [{
                        label: 'Memory Usage (MB)',
                        data: stats.memValues,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            // Pressure chart
            const pressureCtx = document.getElementById('pressureChart').getContext('2d');
            if (pressureChart) pressureChart.destroy();
            pressureChart = new Chart(pressureCtx, {
                type: 'doughnut',
                data: {
                    labels: Object.keys(stats.pressureCounts),
                    datasets: [{
                        data: Object.values(stats.pressureCounts),
                        backgroundColor: ['#4caf50', '#ff9800', '#f44336', '#9e9e9e']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            // Dimension chart
            const dimCtx = document.getElementById('dimensionChart').getContext('2d');
            if (dimensionChart) dimensionChart.destroy();
            const dimLabels = Object.keys(stats.dimCounts).sort((a, b) => parseInt(a) - parseInt(b));
            dimensionChart = new Chart(dimCtx, {
                type: 'bar',
                data: {
                    labels: dimLabels.map(d => `${d}D`),
                    datasets: [{
                        label: 'Snapshots',
                        data: dimLabels.map(d => stats.dimCounts[d]),
                        backgroundColor: '#764ba2'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }

        function displayProgression(stats) {
            const tbody = document.getElementById('progressionBody');
            tbody.innerHTML = '';
            
            stats.progressionPoints.forEach(p => {
                const s = p.snapshot;
                const memMB = s.memory.heapUsed / 1024 / 1024;
                const pressure = s.reasoning.memoryPressure || 'unknown';
                const pressureClass = pressure === 'low' ? 'status-low' : pressure === 'medium' ? 'status-medium' : 'status-high';
                
                const row = tbody.insertRow();
                row.insertCell(0).textContent = p.label;
                row.insertCell(1).textContent = memMB.toFixed(2);
                row.insertCell(2).textContent = s.automatonState.objectCount;
                row.insertCell(3).textContent = s.automatonState.selfModificationCount;
                row.insertCell(4).textContent = `${s.automatonState.currentDimension}D`;
                row.insertCell(5).innerHTML = `<span class="status-badge ${pressureClass}">${pressure.toUpperCase()}</span>`;
            });
        }

        function displayPhases(stats) {
            const tbody = document.getElementById('phasesBody');
            tbody.innerHTML = '';
            
            stats.phases.forEach(p => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = `Phase ${p.phase}`;
                row.insertCell(1).textContent = p.range;
                row.insertCell(2).textContent = `${p.startMem}MB`;
                row.insertCell(3).textContent = `${p.endMem}MB`;
                row.insertCell(4).textContent = `${p.growth}MB`;
                row.insertCell(5).textContent = `${p.growthRate}MB/sec`;
                row.insertCell(6).textContent = p.objectsChange > 0 ? `+${p.objectsChange}` : p.objectsChange;
            });
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function exportReport() {
            if (snapshots.length === 0) {
                alert('No snapshots loaded. Please load snapshots first.');
                return;
            }

            const stats = calculateStats();
            const report = {
                generated: new Date().toISOString(),
                summary: {
                    totalSnapshots: stats.totalSnapshots,
                    timeSpan: stats.timeSpan,
                    memory: {
                        start: stats.memStart,
                        end: stats.memEnd,
                        peak: stats.memPeak,
                        change: stats.memChange,
                        volatility: stats.volatility
                    },
                    qualityScore: stats.qualityScore,
                    pressureDistribution: stats.pressureCounts,
                    dimensionDistribution: stats.dimCounts
                },
                progression: stats.progressionPoints.map(p => ({
                    stage: p.label,
                    memory: p.snapshot.memory.heapUsed / 1024 / 1024,
                    objects: p.snapshot.automatonState.objectCount,
                    modifications: p.snapshot.automatonState.selfModificationCount,
                    dimension: p.snapshot.automatonState.currentDimension,
                    pressure: p.snapshot.reasoning.memoryPressure
                })),
                phases: stats.phases
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snapshot-analysis-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Auto-load on page load if path is provided
        window.addEventListener('load', () => {
            // Try to load if path looks valid
            const path = document.getElementById('snapshotPath').value;
            if (path && path !== '../../snapshots-memory') {
                // Don't auto-load, wait for user action
            }
        });
    </script>
</body>
</html>
