@top { CanvasL }

@tokens {
  newline { "\n" | "\r\n" }
  whitespace { " " | "\t" }
  jsonObjectStart { "{" }
  jsonObjectEnd { "}" }
  jsonArrayStart { "[" }
  jsonArrayEnd { "]" }
  jsonString { "\"" [^"]* "\"" }
  jsonNumber { [0-9]+ ("." [0-9]+)? }
  jsonBoolean { "true" | "false" }
  jsonNull { "null" }
  jsonColon { ":" }
  jsonComma { "," }
  jsonKey { [a-zA-Z_][a-zA-Z0-9_-]* }
  jsonValue { [^,\}\]]+ }
  comment { "//" [^\n]* | "/*" [^*]* "*" ("/" [^*]* "*")* "/" }
  
  // CanvasL-specific tokens
  canvaslDirective { "@" [a-zA-Z_][a-zA-Z0-9_-]* }
  canvaslReference { "#" [a-zA-Z0-9_-]+ }
  canvaslDimension { [0-7] "D" }
  canvaslType { "node" | "edge" | "graph" | "automaton" | "shacl" | "rfc2119" | "asp" | "r5rs" }
  canvaslEdgeType { "vertical" | "horizontal" | "transition" | "self-ref" | "r5rs-call" }
  canvaslR5RSFunction { "r5rs:" [a-zA-Z_][a-zA-Z0-9_-]* }
  canvaslSchemeExpression { "(" [^)]* ")" }
  
  // Bipartite-BQF tokens
  // Note: These match string values within JSON strings
  // The actual JSON will have: "partition": "topology" where jsonString matches "topology"
  // We use jsonString in rules and validate content separately
}

@skip {
  whitespace
  comment
}

CanvasL {
  CanvasLEntry*
}

CanvasLEntry {
  CanvasLDirective? JSONLObject
}

CanvasLDirective {
  canvaslDirective jsonColon JSONLValue
}

JSONLObject {
  JSONLProperty (jsonComma JSONLProperty)*
}

JSONLProperty {
  jsonKey jsonColon JSONLValue
}

JSONLValue {
  jsonString | jsonNumber | jsonBoolean | jsonNull | JSONLObject | JSONLArray | 
  canvaslReference | canvaslDimension | canvaslR5RSFunction | canvaslSchemeExpression | jsonValue
}

// Note: BipartiteMetadata is recognized via JSONLProperty when key is "bipartite"
// BipartiteObject is a JSONLObject, so it's already parseable as JSONLValue

JSONLArray {
  jsonArrayStart JSONLValue (jsonComma JSONLValue)* jsonArrayEnd
}

// CanvasL-specific structures
CanvasLNode {
  "id" jsonColon jsonString jsonComma
  "type" jsonColon canvaslType jsonComma
  JSONLProperty*
}

CanvasLEdge {
  "id" jsonColon jsonString jsonComma
  "type" jsonColon canvaslEdgeType jsonComma
  ("from" | "fromNode") jsonColon (jsonString | canvaslReference) jsonComma
  ("to" | "toNode") jsonColon (jsonString | canvaslReference) jsonComma
  JSONLProperty*
}

CanvasLR5RSCall {
  "function" jsonColon canvaslR5RSFunction jsonComma
  "args" jsonColon JSONLArray jsonComma
  JSONLProperty*
}

// Bipartite-BQF structures
BipartiteMetadata {
  "bipartite" jsonColon BipartiteObject
}

BipartiteObject {
  jsonObjectStart
  ("partition" jsonColon BipartitePartition (jsonComma)?)?
  ("bqf" jsonColon (BQFObject | BQFTransformation) (jsonComma)?)?
  ("polynomial" jsonColon PolynomialObject (jsonComma)?)?
  ("progression" jsonColon jsonString (jsonComma)?)?
  ("mapping" jsonColon jsonString (jsonComma)?)?
  jsonObjectEnd
}

BipartitePartition {
  jsonString
  // Validates: "topology" | "system" | "topology-system" | "topology-topology" | "system-system"
  // Actual validation happens in parser/AST layer
}

BQFObject {
  jsonObjectStart
  "form" jsonColon jsonString (jsonComma)?
  ("coefficients" jsonColon JSONLArray (jsonComma)?)?
  ("signature" jsonColon jsonString (jsonComma)?)?
  // Validates: "euclidean" | "lorentz" | "minkowski" | "riemannian"
  // Actual validation happens in parser/AST layer
  ("variables" jsonColon JSONLArray (jsonComma)?)?
  ("polynomial" jsonColon jsonString (jsonComma)?)?
  ("symbol" jsonColon jsonString (jsonComma)?)?
  ("procedure" jsonColon jsonString (jsonComma)?)?
  jsonObjectEnd
}

BQFTransformation {
  jsonObjectStart
  "from" jsonColon BQFObject (jsonComma)?
  "to" jsonColon BQFObject (jsonComma)?
  ("transformation" jsonColon jsonString (jsonComma)?)?
  ("polynomial" jsonColon jsonString (jsonComma)?)?
  jsonObjectEnd
}

PolynomialObject {
  jsonObjectStart
  "monad" jsonColon JSONLArray jsonComma
  "functor" jsonColon JSONLArray jsonComma
  "perceptron" jsonColon JSONLArray
  jsonObjectEnd
}
