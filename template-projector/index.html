<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CanvasL Semantic Slides Viewer</title>
  <link rel="stylesheet" href="css/viewer.css">
</head>
<body>
  <div id="viewer">
    <nav id="slide-nav">
      <button id="prev">‚Üê</button>
      <span id="slide-counter">1 / 1</span>
      <button id="next">‚Üí</button>
      <button id="re-render" title="Re-render and re-populate current slide">‚ö°</button>
      <button id="generate-topic" title="Generate slide from topic">‚ú®</button>
      <button id="blackboard" title="Open blackboard editor">üìù</button>
      <button id="fullscreen">‚õ∂</button>
    </nav>
    
    <!-- Topic Input Modal -->
    <div id="topic-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1001; overflow: auto;">
      <div style="max-width: 800px; margin: 2rem auto; background: #1a1a1a; padding: 2rem; border-radius: 1rem; border: 2px solid #00ffff;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h2 style="color: #00ffff; margin: 0;">Generate Slide from Topic</h2>
          <button id="close-topic-modal" style="background: #ff4444; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer;">√ó</button>
        </div>
        <div style="margin-bottom: 1rem;">
          <label style="color: #f0f0f0; display: block; margin-bottom: 0.5rem; font-weight: bold;">Topic:</label>
          <input type="text" id="topic-input" placeholder="e.g., quantum computing, blockchain consensus, neural networks..." style="width: 100%; padding: 0.75rem; background: #0a0a0a; color: #f0f0f0; border: 2px solid #00ffff; border-radius: 0.5rem; font-size: 1rem;" />
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div>
            <label style="color: #f0f0f0; display: block; margin-bottom: 0.5rem;">Dimension (optional):</label>
            <select id="topic-dimension" style="width: 100%; padding: 0.5rem; background: #0a0a0a; color: #f0f0f0; border: 1px solid #333; border-radius: 0.5rem;">
              <option value="">Auto-detect</option>
              <option value="0D">0D - Topology</option>
              <option value="1D">1D - Temporal</option>
              <option value="2D">2D - Structural</option>
              <option value="3D">3D - Algebraic</option>
              <option value="4D">4D - Network</option>
              <option value="5D">5D - Consensus</option>
              <option value="6D">6D - Intelligence</option>
              <option value="7D">7D - Quantum</option>
            </select>
          </div>
          <div>
            <label style="color: #f0f0f0; display: block; margin-bottom: 0.5rem;">Partition (optional):</label>
            <select id="topic-partition" style="width: 100%; padding: 0.5rem; background: #0a0a0a; color: #f0f0f0; border: 1px solid #333; border-radius: 0.5rem;">
              <option value="">Auto-detect</option>
              <option value="topology">Topology</option>
              <option value="system">System</option>
            </select>
          </div>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <button id="generate-topic-slide" style="background: #00ff00; color: #000; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold; flex: 1;">Generate Slide</button>
          <button id="cancel-topic" style="background: #666; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;">Cancel</button>
        </div>
        <div id="topic-status" style="margin-top: 1rem; color: #888; font-size: 0.875rem;"></div>
      </div>
    </div>
    
    <!-- Blackboard Editor Modal -->
    <div id="blackboard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; overflow: auto;">
      <div style="max-width: 1200px; margin: 2rem auto; background: #1a1a1a; padding: 2rem; border-radius: 1rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h2 style="color: #00ffff; margin: 0;">Blackboard Editor</h2>
          <button id="close-blackboard" style="background: #ff4444; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer;">Close</button>
        </div>
        <div style="margin-bottom: 1rem;">
          <label style="color: #f0f0f0; display: block; margin-bottom: 0.5rem;">Select File to Edit:</label>
          <select id="blackboard-file-select" style="width: 100%; padding: 0.5rem; background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; border-radius: 0.5rem; margin-bottom: 1rem;">
            <option value="content-index.jsonl">Content Index (content-index.jsonl)</option>
            <option value="automaton-kernel.jsonl">Automaton Kernel (automaton-kernel.jsonl)</option>
          </select>
          <label style="color: #f0f0f0; display: block; margin-bottom: 0.5rem;">Edit File Content:</label>
          <textarea id="blackboard-content" style="width: 100%; height: 400px; background: #0a0a0a; color: #00ff00; font-family: monospace; padding: 1rem; border: 1px solid #333; border-radius: 0.5rem; font-size: 12px;"></textarea>
        </div>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
          <button id="save-blackboard" style="background: #00ff00; color: #000; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-weight: bold;">Save Changes</button>
          <button id="reload-blackboard" style="background: #00aaff; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;">Reload from Server</button>
          <button id="rebuild-blackboard" style="background: #ffaa00; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;">Rebuild Index</button>
          <button id="apply-blackboard" style="background: #aa00ff; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;">Apply & Reload</button>
        </div>
        <div id="blackboard-status" style="margin-top: 1rem; color: #888; font-size: 0.875rem;"></div>
      </div>
    </div>
    
    <canvas id="render-canvas"></canvas>
    
    <div id="interaction-layer"></div>
    
    <!-- Suggestions Panel -->
    <div id="suggestions-panel" style="display: none; position: fixed; right: 0; top: 0; width: 400px; height: 100vh; background: rgba(26, 26, 26, 0.95); border-left: 2px solid #00ffff; z-index: 999; overflow-y: auto; padding: 1rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3 style="color: #00ffff; margin: 0;">Agent Suggestions</h3>
        <button id="close-suggestions" style="background: #ff4444; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;">√ó</button>
      </div>
      <div id="suggestions-content"></div>
    </div>
    
    <div id="status-bar">
      <span id="status">Ready</span>
    </div>
  </div>

  <script type="module">
    import { Projector } from './src/projector/Projector.js';
    import { AgentWorkerCoordinator } from './src/workers/AgentWorkerCoordinator.js';
    import { TopicSlideGenerator } from './src/projector/TopicSlideGenerator.js';
    
    // Initialize projector
    const projector = new Projector();
    const canvas = document.getElementById('render-canvas');
    
    // Initialize agent worker coordinator
    const agentWorkerCoordinator = new AgentWorkerCoordinator();
    
    // Initialize topic slide generator
    let topicSlideGenerator = null;
    
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');
    const reRenderBtn = document.getElementById('re-render');
    const generateTopicBtn = document.getElementById('generate-topic');
    const blackboardBtn = document.getElementById('blackboard');
    const slideCounter = document.getElementById('slide-counter');
    const statusBar = document.getElementById('status');
    
    // Topic modal elements
    const topicModal = document.getElementById('topic-modal');
    const topicInput = document.getElementById('topic-input');
    const topicDimension = document.getElementById('topic-dimension');
    const topicPartition = document.getElementById('topic-partition');
    const generateTopicSlideBtn = document.getElementById('generate-topic-slide');
    const closeTopicModal = document.getElementById('close-topic-modal');
    const cancelTopic = document.getElementById('cancel-topic');
    const topicStatus = document.getElementById('topic-status');
    
    // Blackboard editor elements
    const blackboardModal = document.getElementById('blackboard-modal');
    const blackboardFileSelect = document.getElementById('blackboard-file-select');
    const blackboardContent = document.getElementById('blackboard-content');
    const closeBlackboard = document.getElementById('close-blackboard');
    const saveBlackboard = document.getElementById('save-blackboard');
    const reloadBlackboard = document.getElementById('reload-blackboard');
    const rebuildBlackboard = document.getElementById('rebuild-blackboard');
    const applyBlackboard = document.getElementById('apply-blackboard');
    const blackboardStatus = document.getElementById('blackboard-status');
    
    // Suggestions panel elements
    const suggestionsPanel = document.getElementById('suggestions-panel');
    const suggestionsContent = document.getElementById('suggestions-content');
    const closeSuggestions = document.getElementById('close-suggestions');
    
    // Current file being edited
    let currentBlackboardFile = 'content-index.jsonl';
    
    // Current suggestions
    let currentSuggestions = [];
    
    // Render function
    function render() {
      try {
        console.log('Render called, current slide:', projector.currentSlide?.id);
        projector.renderToCanvas(canvas);
        const current = projector.getCurrentSlideIndex();
        const total = projector.slides.length;
        slideCounter.textContent = `${current} / ${total}`;
      } catch (error) {
        console.error('Render error:', error);
        statusBar.textContent = `Render error: ${error.message}`;
      }
    }
    
    // Navigation handlers
    prevBtn.addEventListener('click', () => {
      projector.prevSlide();
      render();
    });
    
    nextBtn.addEventListener('click', () => {
      projector.nextSlide();
      render();
    });
    
    // Re-render button handler (background population, no suggestions unless requested)
    reRenderBtn.addEventListener('click', async () => {
      if (projector.currentSlide) {
        statusBar.textContent = 'Re-rendering slide...';
        try {
          const slide = projector.currentSlide;
          const dimension = slide.dimension || '0D';
          
          // Populate in background (non-blocking)
          populateSlideInBackground(slide, dimension);
          
          render();
          statusBar.textContent = 'Slide re-rendered';
        } catch (error) {
          console.error('Failed to re-render slide:', error);
          statusBar.textContent = `Error: ${error.message}`;
        }
      } else {
        statusBar.textContent = 'No slide selected';
      }
    });
    
    // Background population (non-blocking, no suggestions)
    async function populateSlideInBackground(slide, dimension) {
      // Don't use requestIdleCallback - render immediately after population
      try {
        let contentData = [];
        if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
          await projector.agentCoordinator.contentLoader.loadAll();
          contentData = projector.agentCoordinator.contentLoader.getAllEntries();
        }
        
        console.log(`Populating slide ${slide.id} in background...`);
        
        // Populate without generating suggestions
        const { slide: populatedSlide } = await agentWorkerCoordinator.populateSlide(
          slide,
          contentData,
          dimension
        );
        
        console.log(`Slide ${populatedSlide.id} populated, updating...`);
        
        // Update slide in slides array
        const slideIndex = projector.slides.findIndex(s => s.id === populatedSlide.id);
        if (slideIndex >= 0) {
          projector.slides[slideIndex] = populatedSlide;
          console.log(`Updated slide at index ${slideIndex}`);
        }
        
        // Update current slide if it's the one being populated
        if (projector.currentSlide && (projector.currentSlide.id === populatedSlide.id || projector.currentSlide === slide)) {
          projector.currentSlide = populatedSlide;
          console.log(`Updated current slide, re-rendering...`);
          render();
        }
      } catch (error) {
        console.error('Background population failed:', error);
      }
    }
    
    // Query/search handler - generates suggestions on query
    function handleQuery(query) {
      if (!query || !query.trim()) return;
      
      statusBar.textContent = `Querying: ${query}...`;
      
      // Generate suggestions based on query
      const slide = projector.currentSlide;
      if (!slide) {
        statusBar.textContent = 'No slide selected';
        return;
      }
      
      const dimension = slide.dimension || '0D';
      
      // Get content data
      let contentData = [];
      if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
        contentData = projector.agentCoordinator.contentLoader.getAllEntries();
      }
      
      // Generate suggestions for query
      agentWorkerCoordinator.generateSuggestions(slide, { type: 'query', text: query }, 'query')
        .then(suggestions => {
          if (suggestions && suggestions.length > 0) {
            currentSuggestions = suggestions;
            displaySuggestions(suggestions, 'query');
            suggestionsPanel.style.display = 'block';
            statusBar.textContent = `Found ${suggestions.length} suggestions for "${query}"`;
          } else {
            statusBar.textContent = `No suggestions for "${query}"`;
          }
        })
        .catch(error => {
          console.error('Query failed:', error);
          statusBar.textContent = `Query error: ${error.message}`;
        });
    }
    
    // Keyword click handler - generates suggestions on keyword click
    function handleKeywordClick(keyword) {
      if (!keyword) return;
      
      statusBar.textContent = `Analyzing keyword: ${keyword}...`;
      
      const slide = projector.currentSlide;
      if (!slide) {
        statusBar.textContent = 'No slide selected';
        return;
      }
      
      const dimension = slide.dimension || '0D';
      let contentData = [];
      if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
        contentData = projector.agentCoordinator.contentLoader.getAllEntries();
      }
      
      // Generate suggestions for keyword
      agentWorkerCoordinator.generateSuggestions(slide, { type: 'keyword', text: keyword }, 'keyword_click')
        .then(suggestions => {
          if (suggestions && suggestions.length > 0) {
            currentSuggestions = suggestions;
            displaySuggestions(suggestions, 'keyword');
            suggestionsPanel.style.display = 'block';
            statusBar.textContent = `Generated ${suggestions.length} suggestions for "${keyword}"`;
          } else {
            statusBar.textContent = `No suggestions for "${keyword}"`;
          }
        })
        .catch(error => {
          console.error('Keyword analysis failed:', error);
          statusBar.textContent = `Error: ${error.message}`;
        });
    }
    
    // Close suggestions panel
    closeSuggestions.addEventListener('click', () => {
      suggestionsPanel.style.display = 'none';
    });
    
    // Display suggestions
    function displaySuggestions(suggestions, action) {
      if (!suggestions || suggestions.length === 0) {
        suggestionsContent.innerHTML = '<p style="color: #888;">No suggestions available</p>';
        return;
      }
      
      const html = suggestions.map((suggestion, index) => {
        const priorityColor = {
          high: '#ff4444',
          medium: '#ffaa00',
          low: '#00aaff'
        }[suggestion.priority] || '#888';
        
        return `
          <div style="background: #1a1a1a; border-left: 4px solid ${priorityColor}; padding: 1rem; margin-bottom: 1rem; border-radius: 0.25rem;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.5rem;">
              <span style="color: ${priorityColor}; font-size: 0.75rem; font-weight: bold; text-transform: uppercase;">${suggestion.priority}</span>
              <span style="color: #888; font-size: 0.75rem;">${suggestion.type}</span>
            </div>
            <p style="color: #f0f0f0; margin: 0.5rem 0;">${suggestion.message}</p>
            <button onclick="applySuggestion(${index})" style="background: #00ffff; color: #000; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem; margin-top: 0.5rem;">Apply</button>
          </div>
        `;
      }).join('');
      
      suggestionsContent.innerHTML = html;
    }
    
    // Apply suggestion
    window.applySuggestion = async function(index) {
      const suggestion = currentSuggestions[index];
      if (!suggestion) return;
      
      statusBar.textContent = `Applying suggestion: ${suggestion.type}...`;
      
      try {
        // Handle different suggestion types
        switch (suggestion.action) {
          case 'enhance_title':
            // Enhance title logic
            if (projector.currentSlide) {
              projector.currentSlide.title = projector.currentSlide.title + ' (Enhanced)';
              render();
            }
            break;
          
          case 'add_content':
            // Add content logic
            if (projector.currentSlide) {
              projector.currentSlide.content = (projector.currentSlide.content || '') + '\n\n[Additional content added by agent]';
              render();
            }
            break;
          
          case 'add_components':
            // Add components logic
            if (projector.currentSlide) {
              if (!projector.currentSlide.uiComponents) {
                projector.currentSlide.uiComponents = [];
              }
              projector.currentSlide.uiComponents.push({
                type: 'quote',
                text: 'Consider adding visual components to enhance this slide.'
              });
              render();
            }
            break;
          
          default:
            console.log('Suggestion action not implemented:', suggestion.action);
        }
        
        statusBar.textContent = 'Suggestion applied';
        
        // Remove suggestion from list
        currentSuggestions.splice(index, 1);
        displaySuggestions(currentSuggestions, 'populate');
      } catch (error) {
        console.error('Failed to apply suggestion:', error);
        statusBar.textContent = `Error: ${error.message}`;
      }
    };
    
    // Worker events disabled - suggestions only on query/keyword click
    // No automatic suggestion generation
    
    // Load file for editing
    async function loadBlackboardFile(filename) {
      try {
        const response = await fetch(`/${filename}`);
        if (response.ok) {
          const content = await response.text();
          blackboardContent.value = content;
          currentBlackboardFile = filename;
          blackboardStatus.textContent = `${filename} loaded`;
          return true;
        } else {
          blackboardContent.value = `// ${filename} not found. Click "Rebuild Index" to generate it.`;
          blackboardStatus.textContent = `${filename} not found`;
          return false;
        }
      } catch (error) {
        blackboardContent.value = `// Error loading ${filename}: ${error.message}`;
        blackboardStatus.textContent = `Error: ${error.message}`;
        return false;
      }
    }
    
    // Topic generation handlers
    generateTopicBtn.addEventListener('click', () => {
      topicModal.style.display = 'block';
      topicInput.focus();
    });
    
    closeTopicModal.addEventListener('click', () => {
      topicModal.style.display = 'none';
      topicInput.value = '';
      topicDimension.value = '';
      topicPartition.value = '';
      topicStatus.textContent = '';
    });
    
    cancelTopic.addEventListener('click', () => {
      topicModal.style.display = 'none';
      topicInput.value = '';
      topicDimension.value = '';
      topicPartition.value = '';
      topicStatus.textContent = '';
    });
    
    generateTopicSlideBtn.addEventListener('click', async () => {
      const topic = topicInput.value.trim();
      if (!topic) {
        topicStatus.textContent = '‚ö†Ô∏è Please enter a topic';
        topicStatus.style.color = '#ffaa00';
        return;
      }
      
      topicStatus.textContent = 'Generating slide...';
      topicStatus.style.color = '#00aaff';
      generateTopicSlideBtn.disabled = true;
      
      try {
        if (!topicSlideGenerator) {
          topicSlideGenerator = new TopicSlideGenerator(
            projector.agentCoordinator,
            projector.agentCoordinator.contentLoader
          );
        }
        
        const dimension = topicDimension.value || null;
        const partition = topicPartition.value || null;
        
        const slide = await topicSlideGenerator.generateSlideFromTopic(topic, {
          dimension,
          partition
        });
        
        // Add slide to deck
        projector.slides.push(slide);
        projector.currentSlide = slide;
        
        // Render the new slide
        render();
        
        // Close modal
        topicModal.style.display = 'none';
        topicInput.value = '';
        topicDimension.value = '';
        topicPartition.value = '';
        topicStatus.textContent = '';
        
        statusBar.textContent = `Generated slide: "${slide.title}"`;
      } catch (error) {
        console.error('Failed to generate topic slide:', error);
        topicStatus.textContent = `‚ùå Error: ${error.message}`;
        topicStatus.style.color = '#ff4444';
      } finally {
        generateTopicSlideBtn.disabled = false;
      }
    });
    
    // Allow Enter key to generate slide
    topicInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        generateTopicSlideBtn.click();
      }
    });
    
    // Blackboard editor handlers
    blackboardBtn.addEventListener('click', async () => {
      await loadBlackboardFile(blackboardFileSelect.value);
      blackboardModal.style.display = 'block';
    });
    
    // File selector change handler
    blackboardFileSelect.addEventListener('change', async (e) => {
      await loadBlackboardFile(e.target.value);
    });
    
    closeBlackboard.addEventListener('click', () => {
      blackboardModal.style.display = 'none';
    });
    
    saveBlackboard.addEventListener('click', async () => {
      try {
        const content = blackboardContent.value;
        // In a real implementation, this would save to server
        // For now, we'll reload the content loader
        blackboardStatus.textContent = 'Saving...';
        
        // Reload content loader with new content
        if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
          await projector.agentCoordinator.contentLoader.reload();
          await projector.populateSlides(true);
          render();
        }
        
        blackboardStatus.textContent = 'Saved! (Note: Browser-only - changes not persisted to server)';
        setTimeout(() => {
          blackboardModal.style.display = 'none';
        }, 1000);
      } catch (error) {
        blackboardStatus.textContent = `Error saving: ${error.message}`;
      }
    });
    
    reloadBlackboard.addEventListener('click', async () => {
      await loadBlackboardFile(currentBlackboardFile);
    });
    
    applyBlackboard.addEventListener('click', async () => {
      try {
        blackboardStatus.textContent = 'Applying changes...';
        
        // Reload content loader with new content
        if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
          await projector.agentCoordinator.contentLoader.reload();
          await projector.populateSlides(true);
          render();
          blackboardStatus.textContent = 'Changes applied! Slides reloaded.';
        } else {
          blackboardStatus.textContent = 'ContentLoader not available';
        }
      } catch (error) {
        blackboardStatus.textContent = `Error applying: ${error.message}`;
      }
    });
    
    rebuildBlackboard.addEventListener('click', async () => {
      try {
        blackboardStatus.textContent = 'Rebuilding content index...';
        // Trigger rebuild via API (if available) or show instructions
        blackboardStatus.textContent = 'Run "npm run build:content-index" to rebuild. Reload page after rebuilding.';
      } catch (error) {
        blackboardStatus.textContent = `Error: ${error.message}`;
      }
    });
    
    // Fullscreen handler
    document.getElementById('fullscreen').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      render();
    });
    
    // Handle canvas clicks for component/keyword interaction
    canvas.addEventListener('click', async (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Check if click is on a component
      const slide = projector.currentSlide;
      if (slide && slide._componentAreas) {
        for (const area of slide._componentAreas) {
          if (x >= area.x && x <= area.x + area.width &&
              y >= area.y && y <= area.y + area.height) {
            // Component clicked - treat as keyword click
            const keyword = area.component.alt || area.component.text || area.type;
            handleKeywordClick(keyword);
            return;
          }
        }
      }
      
      // Check if click is on a keyword in text content
      // Extract word at click position
      const ctx = canvas.getContext('2d');
      const content = slide.content || slide.text || '';
      if (content) {
        // Simple keyword extraction - find word near click
        const lines = content.split('\n');
        let currentY = 80; // Start after title
        for (const line of lines) {
          if (y >= currentY && y <= currentY + 30) {
            // Click is on this line - extract word
            const words = line.split(/\s+/);
            const charWidth = 10; // Approximate
            const charIndex = Math.floor((x - 60) / charWidth);
            let charCount = 0;
            for (const word of words) {
              if (charCount + word.length >= charIndex) {
                // Found the word
                if (word.length > 3) { // Only treat longer words as keywords
                  handleKeywordClick(word.replace(/[^\w]/g, ''));
                }
                return;
              }
              charCount += word.length + 1; // +1 for space
            }
          }
          currentY += 30;
        }
      }
    });
    
    // Add search/query input (optional - can be added to UI later)
    window.querySlide = function(query) {
      handleQuery(query);
    };
    
    window.clickKeyword = function(keyword) {
      handleKeywordClick(keyword);
    };
    
    // Preload content sources on empty page (before deck loads)
    async function preloadContentSources() {
      try {
        statusBar.textContent = 'Preloading content sources...';
        
        // Initialize projector
        await projector.init(projector.metaLog);
        
        // Preload content sources (kernel + frontmatter)
        if (projector.agentCoordinator && projector.agentCoordinator.contentLoader) {
          await projector.agentCoordinator.contentLoader.loadAll();
          statusBar.textContent = 'Content sources preloaded - ready for blackboard editing';
          console.log('Content sources preloaded:', {
            kernel: projector.agentCoordinator.contentLoader.kernelLoader.getAllEntries().length,
            frontmatter: projector.agentCoordinator.contentLoader.frontmatterLoader.getAllDocuments().length
          });
        }
      } catch (error) {
        console.warn('Preload failed (will retry on deck load):', error);
        statusBar.textContent = 'Preload skipped - will load with deck';
      }
    }
    
    // Initialize on load
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Preload content sources first (enables blackboard editing)
        await preloadContentSources();
        
        // Initialize topic slide generator after projector is ready
        topicSlideGenerator = new TopicSlideGenerator(
          projector.agentCoordinator,
          projector.agentCoordinator.contentLoader
        );
        
        // Load initial automaton agents overview slide first
        try {
          const agentsOverviewDeck = await projector.loadDeck('templates/slides/automaton-agents-overview.canvasl.jsonl');
          if (agentsOverviewDeck.slides && agentsOverviewDeck.slides.length > 0) {
            projector.currentSlide = agentsOverviewDeck.slides[0];
            projector.slides = [agentsOverviewDeck.slides[0]]; // Start with just the overview
            render();
            statusBar.textContent = 'Automaton Agents Overview loaded';
          }
        } catch (error) {
          console.warn('Failed to load automaton agents overview:', error);
        }
        
        // Then load demo deck (append to existing slides)
        const initialSlideCount = projector.slides.length;
        const deck = await projector.loadDeck('templates/documents/demo-deck.canvasl.jsonl');
        
        // Ensure overview slide stays at the beginning
        if (initialSlideCount > 0 && projector.slides.length > initialSlideCount) {
          const overviewSlide = projector.slides[0];
          const demoSlides = projector.slides.slice(initialSlideCount);
          projector.slides = [overviewSlide, ...demoSlides];
          projector.currentSlide = overviewSlide; // Keep overview as current
        }
        
        console.log('Deck loaded:', deck);
        console.log('Slides found:', projector.slides.length);
        console.log('Slide IDs:', projector.slides.map(s => s.id || 'unnamed'));
        
        // Check for missing slides
        const expectedSlides = ["slide-1", "1d-temporal-slide", "2d-structural-slide", "einstein-slide", "la-slide", "5d-consensus-slide", "6d-intelligence-slide", "7d-quantum-slide", "meta-log-slide", "canvasl-slide", "agents-slide", "semantic-slides-slide"];
        const loadedSlideIds = projector.slides.map(s => s.id).filter(Boolean);
        const missingSlides = expectedSlides.filter(id => !loadedSlideIds.includes(id));
        
        // Check for include errors
        if (projector.includeLoader && projector.includeLoader.loadErrors && projector.includeLoader.loadErrors.length > 0) {
          console.error('Include file errors:', projector.includeLoader.loadErrors);
          statusBar.textContent = `Error: ${projector.includeLoader.loadErrors.length} include files failed to load`;
        }
        
        if (missingSlides.length > 0) {
          console.warn('Missing slides:', missingSlides);
          console.warn('Loaded slide IDs:', loadedSlideIds);
          statusBar.textContent = `Loaded ${projector.slides.length}/${expectedSlides.length} slides (missing: ${missingSlides.join(', ')})`;
        } else {
          statusBar.textContent = `Loaded ${projector.slides.length} slides`;
        }
        
        // Render first slide
        if (projector.slides && projector.slides.length > 0) {
          projector.currentSlide = projector.slides[0];
          render();
        } else {
          console.error('No slides loaded!');
          statusBar.textContent = 'Error: No slides loaded';
        }
        
        // Auto-revolving disabled - slides only change on user request
        // Agents work in background - no automatic population
        // Suggestions only generated on query or keyword click
        
        // Update status when slides revolve
        const originalNextSlide = projector.nextSlide.bind(projector);
        projector.nextSlide = function() {
          const result = originalNextSlide();
          const current = projector.getCurrentSlideIndex();
          const total = projector.slides.length;
          slideCounter.textContent = `${current} / ${total}`;
          return result;
        };
      } catch (error) {
        console.error('Failed to initialize:', error);
        statusBar.textContent = `Error: ${error.message}`;
        // Render error message
        projector.renderToCanvas(canvas);
      }
    });
    
    
    // Export for debugging
    window.projector = projector;
  </script>
</body>
</html>
